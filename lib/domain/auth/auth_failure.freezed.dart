// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$AuthFailureTearOff {
  const _$AuthFailureTearOff();

// ignore: unused_element
  EmailIsAlreadyInUse emailIsAlreadyInUse() {
    return const EmailIsAlreadyInUse();
  }

// ignore: unused_element
  WrongEmailAndPasswordCompination wrongEmailAndPasswordCompination() {
    return const WrongEmailAndPasswordCompination();
  }

// ignore: unused_element
  ServerError serverError() {
    return const ServerError();
  }

// ignore: unused_element
  NoSuchLevel noSuchLevel() {
    return const NoSuchLevel();
  }

// ignore: unused_element
  NoSuchCategory noSuchCategory() {
    return const NoSuchCategory();
  }

// ignore: unused_element
  NoTokenFound noTokenFound() {
    return const NoTokenFound();
  }
}

/// @nodoc
// ignore: unused_element
const $AuthFailure = _$AuthFailureTearOff();

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res> implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure _value;
  // ignore: unused_field
  final $Res Function(AuthFailure) _then;
}

/// @nodoc
abstract class $EmailIsAlreadyInUseCopyWith<$Res> {
  factory $EmailIsAlreadyInUseCopyWith(
          EmailIsAlreadyInUse value, $Res Function(EmailIsAlreadyInUse) then) =
      _$EmailIsAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmailIsAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements $EmailIsAlreadyInUseCopyWith<$Res> {
  _$EmailIsAlreadyInUseCopyWithImpl(
      EmailIsAlreadyInUse _value, $Res Function(EmailIsAlreadyInUse) _then)
      : super(_value, (v) => _then(v as EmailIsAlreadyInUse));

  @override
  EmailIsAlreadyInUse get _value => super._value as EmailIsAlreadyInUse;
}

/// @nodoc
class _$EmailIsAlreadyInUse implements EmailIsAlreadyInUse {
  const _$EmailIsAlreadyInUse();

  @override
  String toString() {
    return 'AuthFailure.emailIsAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmailIsAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return emailIsAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailIsAlreadyInUse != null) {
      return emailIsAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return emailIsAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailIsAlreadyInUse != null) {
      return emailIsAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class EmailIsAlreadyInUse implements AuthFailure {
  const factory EmailIsAlreadyInUse() = _$EmailIsAlreadyInUse;
}

/// @nodoc
abstract class $WrongEmailAndPasswordCompinationCopyWith<$Res> {
  factory $WrongEmailAndPasswordCompinationCopyWith(
          WrongEmailAndPasswordCompination value,
          $Res Function(WrongEmailAndPasswordCompination) then) =
      _$WrongEmailAndPasswordCompinationCopyWithImpl<$Res>;
}

/// @nodoc
class _$WrongEmailAndPasswordCompinationCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements $WrongEmailAndPasswordCompinationCopyWith<$Res> {
  _$WrongEmailAndPasswordCompinationCopyWithImpl(
      WrongEmailAndPasswordCompination _value,
      $Res Function(WrongEmailAndPasswordCompination) _then)
      : super(_value, (v) => _then(v as WrongEmailAndPasswordCompination));

  @override
  WrongEmailAndPasswordCompination get _value =>
      super._value as WrongEmailAndPasswordCompination;
}

/// @nodoc
class _$WrongEmailAndPasswordCompination
    implements WrongEmailAndPasswordCompination {
  const _$WrongEmailAndPasswordCompination();

  @override
  String toString() {
    return 'AuthFailure.wrongEmailAndPasswordCompination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WrongEmailAndPasswordCompination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return wrongEmailAndPasswordCompination();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (wrongEmailAndPasswordCompination != null) {
      return wrongEmailAndPasswordCompination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return wrongEmailAndPasswordCompination(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (wrongEmailAndPasswordCompination != null) {
      return wrongEmailAndPasswordCompination(this);
    }
    return orElse();
  }
}

abstract class WrongEmailAndPasswordCompination implements AuthFailure {
  const factory WrongEmailAndPasswordCompination() =
      _$WrongEmailAndPasswordCompination;
}

/// @nodoc
abstract class $ServerErrorCopyWith<$Res> {
  factory $ServerErrorCopyWith(
          ServerError value, $Res Function(ServerError) then) =
      _$ServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$ServerErrorCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $ServerErrorCopyWith<$Res> {
  _$ServerErrorCopyWithImpl(
      ServerError _value, $Res Function(ServerError) _then)
      : super(_value, (v) => _then(v as ServerError));

  @override
  ServerError get _value => super._value as ServerError;
}

/// @nodoc
class _$ServerError implements ServerError {
  const _$ServerError();

  @override
  String toString() {
    return 'AuthFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements AuthFailure {
  const factory ServerError() = _$ServerError;
}

/// @nodoc
abstract class $NoSuchLevelCopyWith<$Res> {
  factory $NoSuchLevelCopyWith(
          NoSuchLevel value, $Res Function(NoSuchLevel) then) =
      _$NoSuchLevelCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoSuchLevelCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $NoSuchLevelCopyWith<$Res> {
  _$NoSuchLevelCopyWithImpl(
      NoSuchLevel _value, $Res Function(NoSuchLevel) _then)
      : super(_value, (v) => _then(v as NoSuchLevel));

  @override
  NoSuchLevel get _value => super._value as NoSuchLevel;
}

/// @nodoc
class _$NoSuchLevel implements NoSuchLevel {
  const _$NoSuchLevel();

  @override
  String toString() {
    return 'AuthFailure.noSuchLevel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoSuchLevel);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return noSuchLevel();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noSuchLevel != null) {
      return noSuchLevel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return noSuchLevel(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noSuchLevel != null) {
      return noSuchLevel(this);
    }
    return orElse();
  }
}

abstract class NoSuchLevel implements AuthFailure {
  const factory NoSuchLevel() = _$NoSuchLevel;
}

/// @nodoc
abstract class $NoSuchCategoryCopyWith<$Res> {
  factory $NoSuchCategoryCopyWith(
          NoSuchCategory value, $Res Function(NoSuchCategory) then) =
      _$NoSuchCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoSuchCategoryCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $NoSuchCategoryCopyWith<$Res> {
  _$NoSuchCategoryCopyWithImpl(
      NoSuchCategory _value, $Res Function(NoSuchCategory) _then)
      : super(_value, (v) => _then(v as NoSuchCategory));

  @override
  NoSuchCategory get _value => super._value as NoSuchCategory;
}

/// @nodoc
class _$NoSuchCategory implements NoSuchCategory {
  const _$NoSuchCategory();

  @override
  String toString() {
    return 'AuthFailure.noSuchCategory()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoSuchCategory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return noSuchCategory();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noSuchCategory != null) {
      return noSuchCategory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return noSuchCategory(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noSuchCategory != null) {
      return noSuchCategory(this);
    }
    return orElse();
  }
}

abstract class NoSuchCategory implements AuthFailure {
  const factory NoSuchCategory() = _$NoSuchCategory;
}

/// @nodoc
abstract class $NoTokenFoundCopyWith<$Res> {
  factory $NoTokenFoundCopyWith(
          NoTokenFound value, $Res Function(NoTokenFound) then) =
      _$NoTokenFoundCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoTokenFoundCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $NoTokenFoundCopyWith<$Res> {
  _$NoTokenFoundCopyWithImpl(
      NoTokenFound _value, $Res Function(NoTokenFound) _then)
      : super(_value, (v) => _then(v as NoTokenFound));

  @override
  NoTokenFound get _value => super._value as NoTokenFound;
}

/// @nodoc
class _$NoTokenFound implements NoTokenFound {
  const _$NoTokenFound();

  @override
  String toString() {
    return 'AuthFailure.noTokenFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoTokenFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailIsAlreadyInUse(),
    @required Result wrongEmailAndPasswordCompination(),
    @required Result serverError(),
    @required Result noSuchLevel(),
    @required Result noSuchCategory(),
    @required Result noTokenFound(),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return noTokenFound();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailIsAlreadyInUse(),
    Result wrongEmailAndPasswordCompination(),
    Result serverError(),
    Result noSuchLevel(),
    Result noSuchCategory(),
    Result noTokenFound(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noTokenFound != null) {
      return noTokenFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    @required
        Result wrongEmailAndPasswordCompination(
            WrongEmailAndPasswordCompination value),
    @required Result serverError(ServerError value),
    @required Result noSuchLevel(NoSuchLevel value),
    @required Result noSuchCategory(NoSuchCategory value),
    @required Result noTokenFound(NoTokenFound value),
  }) {
    assert(emailIsAlreadyInUse != null);
    assert(wrongEmailAndPasswordCompination != null);
    assert(serverError != null);
    assert(noSuchLevel != null);
    assert(noSuchCategory != null);
    assert(noTokenFound != null);
    return noTokenFound(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailIsAlreadyInUse(EmailIsAlreadyInUse value),
    Result wrongEmailAndPasswordCompination(
        WrongEmailAndPasswordCompination value),
    Result serverError(ServerError value),
    Result noSuchLevel(NoSuchLevel value),
    Result noSuchCategory(NoSuchCategory value),
    Result noTokenFound(NoTokenFound value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noTokenFound != null) {
      return noTokenFound(this);
    }
    return orElse();
  }
}

abstract class NoTokenFound implements AuthFailure {
  const factory NoTokenFound() = _$NoTokenFound;
}
